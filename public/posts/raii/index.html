<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Resource Acquisition Is Initialization</title>
<meta name="keywords" content="">
<meta name="description" content="Resource acquisition is initialization (RAII) refers to a programming technique for resource management where the resource acquired by an object when it is initialized is released when the object is destroyed. 1
To explain RAII by example, I will use programs written in C&#43;&#43;.
The setup
For the sake of simplicity, the example will involve allocation of memory on the heap for a floating point variable.
A variable x declared on the heap is assigned 3.14, used and then deleted, freeing up the memory allocated to it when it was declared. Trying to access it after it has been deleted causes &ldquo;undefined behavior&rdquo; that is dependent on the compiler you use, as deletion of the resource associated with x makes it a dangling pointer.">
<meta name="author" content="Debajyoti Debnath">
<link rel="canonical" href="https://www.debdebnath.com/posts/raii/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.25affd57876e8616931aa986244d6b73cafa8eaadc0e3293bf4764e9ac706be6.css" integrity="sha256-Ja/9V4duhhaTGqmGJE1rc8r6jqrcDjKTv0dk6axwa&#43;Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.debdebnath.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.debdebnath.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.debdebnath.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.debdebnath.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.debdebnath.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.debdebnath.com/posts/raii/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://www.debdebnath.com/posts/raii/">
  <meta property="og:title" content="Resource Acquisition Is Initialization">
  <meta property="og:description" content="Resource acquisition is initialization (RAII) refers to a programming technique for resource management where the resource acquired by an object when it is initialized is released when the object is destroyed. 1
To explain RAII by example, I will use programs written in C&#43;&#43;.
The setup For the sake of simplicity, the example will involve allocation of memory on the heap for a floating point variable.
A variable x declared on the heap is assigned 3.14, used and then deleted, freeing up the memory allocated to it when it was declared. Trying to access it after it has been deleted causes “undefined behavior” that is dependent on the compiler you use, as deletion of the resource associated with x makes it a dangling pointer.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-01-21T10:38:06-05:00">
    <meta property="article:modified_time" content="2025-01-21T10:38:06-05:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Resource Acquisition Is Initialization">
<meta name="twitter:description" content="Resource acquisition is initialization (RAII) refers to a programming technique for resource management where the resource acquired by an object when it is initialized is released when the object is destroyed. 1
To explain RAII by example, I will use programs written in C&#43;&#43;.
The setup
For the sake of simplicity, the example will involve allocation of memory on the heap for a floating point variable.
A variable x declared on the heap is assigned 3.14, used and then deleted, freeing up the memory allocated to it when it was declared. Trying to access it after it has been deleted causes &ldquo;undefined behavior&rdquo; that is dependent on the compiler you use, as deletion of the resource associated with x makes it a dangling pointer.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://www.debdebnath.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Resource Acquisition Is Initialization",
      "item": "https://www.debdebnath.com/posts/raii/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Resource Acquisition Is Initialization",
  "name": "Resource Acquisition Is Initialization",
  "description": "Resource acquisition is initialization (RAII) refers to a programming technique for resource management where the resource acquired by an object when it is initialized is released when the object is destroyed. 1\nTo explain RAII by example, I will use programs written in C++.\nThe setup For the sake of simplicity, the example will involve allocation of memory on the heap for a floating point variable.\nA variable x declared on the heap is assigned 3.14, used and then deleted, freeing up the memory allocated to it when it was declared. Trying to access it after it has been deleted causes \u0026ldquo;undefined behavior\u0026rdquo; that is dependent on the compiler you use, as deletion of the resource associated with x makes it a dangling pointer.\n",
  "keywords": [
    
  ],
  "articleBody": "Resource acquisition is initialization (RAII) refers to a programming technique for resource management where the resource acquired by an object when it is initialized is released when the object is destroyed. 1\nTo explain RAII by example, I will use programs written in C++.\nThe setup For the sake of simplicity, the example will involve allocation of memory on the heap for a floating point variable.\nA variable x declared on the heap is assigned 3.14, used and then deleted, freeing up the memory allocated to it when it was declared. Trying to access it after it has been deleted causes “undefined behavior” that is dependent on the compiler you use, as deletion of the resource associated with x makes it a dangling pointer.\n#include int main() { float* x = new float; *x = 3.14; std::cout \u003c\u003c *x \u003c\u003c \"\\n\"; delete x; // *x = 43.12; return 0; } Encapsulation To simplify things and take advantage of C++’s object oriented programming features, we can encapsulate this behavior in a custom class, where the constructor can allocate the required memory and the destructor can release it when the instance goes out of scope.\n... class RAIIFloat { private: float* data; public: RAIIFloat(float value) { data = new float; *data = value; } ~RAIIFloat() { delete data; data = nullptr; } void print() const { std::cout \u003c\u003c *data \u003c\u003c \"\\n\"; } }; int main() { RAIIFloat x(3.14); x.print(); return 0; } No dangling pointers, no new, no delete! And yet, consider the following:\n... int main() { RAIIFloat x(3.14); x.print(); RAIIFloat y = x; y.print(); return 0; } The program compiles fine, yet the error occurs at runtime when both x and y are destroyed. When y is assigned the value of x it effectively points y to the same resource (memory) as x, i.e. creating a shallow copy. So when the resource associated with x gets freed at the end of x’s lifetime, the destruction of y complains of attempting to free a resource that already has been freed.\nRAIIFloat thus lacks an essential trait of RAII, which is that when the resource associated with an object is released, the object should also die. To correct this discrepancy we can either create a deep-copy of the object, or move it entirely to the new object (single ownership).\nDeep-copy while retaining ownership We can modify the copy constructor to perform a deep-copy instead of a shallow copy (also modifying the copy assignment operator to make deep copies).\nclass RAIIFloat { public: ... RAIIFloat(const RAIIFloat\u0026 other) { data = new float(*(other.data)); } RAIIFloat\u0026 operator=(const RAIIFloat \u0026other) { if (data) { if (data != other.data) { *data = *(other.data) } } else { data = new float(*(other.data)); } return *this; }; ... }; The new copy constructor (and copy assignment constructor) makes acquisition and release of resources predictable and bound to the lifetime of the object.\nOwnership transfer, a.k.a. move semantics Alternatively, we can use move semantics in C++ to transfer ownership of a resource to the new object once it is reassigned. This transfer of ownership promotes reuse of existing resources and preserves adherence to RAII principles. Note that for simplicity, in this example we disable the copy constructor instead.\nclass RAIIFloat { public: ... RAIIFloat(RAIIFloat\u0026\u0026 other) { data = other.data; other.data = nullptr; } RAIIFloat\u0026 operator=(RAIIFloat\u0026\u0026 other) { if (data != other.data) { delete data; data = other.data; other.data = nullptr; } return *this; } RAIIFloat(const RAIIFloat\u0026) = delete; RAIIFloat\u0026 operator=(const RAIIFloat \u0026) = delete; ... }; As a result, ownership is now moved to the new object on assignment.\n... int main() { RAIIFloat x(3.14); x.print(); RAIIFloat y = std::move(x); y.print(); // x.print(); return 0; } Calling x.print() segfaults as x no longer owns the memory it was originally assigned.\nConclusion RAII is a programming pattern that ensures efficient and predictable allocation and cleanup of resources (file handles, heap memory, etc.) by tying the initiation and termination of their usage to the lifetime of the entity that invokes them. Using constructors and destructors provided in a programming language that facilitates an object oriented programming paradigm makes the implementation of RAII clean and programmer-friendly.\nStroustrup, B. (2001). Exception safety: concepts and techniques. In Advances in exception handling techniques (pp. 60-76). Berlin, Heidelberg: Springer Berlin Heidelberg. PDF ↩︎\n",
  "wordCount" : "716",
  "inLanguage": "en",
  "datePublished": "2025-01-21T10:38:06-05:00",
  "dateModified": "2025-01-21T10:38:06-05:00",
  "author":{
    "@type": "Person",
    "name": "Debajyoti Debnath"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.debdebnath.com/posts/raii/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.debdebnath.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.debdebnath.com/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://www.debdebnath.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://www.debdebnath.com/experience/" title="Experience">
                    <span>Experience</span>
                </a>
            </li>
            <li>
                <a href="https://www.debdebnath.com/projects/" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="https://www.debdebnath.com/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Resource Acquisition Is Initialization
    </h1>
    <div class="post-meta"><span title='2025-01-21 10:38:06 -0500 EST'>January 21, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Debajyoti Debnath&nbsp;|&nbsp;<a href="https://www.github.com/debajyotid2/personal-website/content/posts/raii.md" rel="noopener noreferrer" target="_blank">Suggest changes</a>

</div>
  </header> 
  <div class="post-content"><p>Resource acquisition is initialization (RAII) refers to a programming technique for resource management where the resource acquired by an object when it is initialized is released when the object is destroyed. <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>To explain RAII by example, I will use programs written in C++.</p>
<h3 id="the-setup">The setup<a hidden class="anchor" aria-hidden="true" href="#the-setup">#</a></h3>
<p>For the sake of simplicity, the example will involve allocation of memory on the heap for a floating point variable.</p>
<p>A variable <code>x</code> declared on the heap is assigned <code>3.14</code>, used and then deleted, freeing up the memory allocated to it when it was declared. Trying to access it after it has been deleted causes &ldquo;undefined behavior&rdquo; that is dependent on the compiler you use, as deletion of the resource associated with <code>x</code> makes it a dangling pointer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span><span style="color:#f92672">*</span> x <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">float</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>; 
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>x <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">delete</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// *x = 43.12;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="encapsulation">Encapsulation<a hidden class="anchor" aria-hidden="true" href="#encapsulation">#</a></h3>
<p>To simplify things and take advantage of C++&rsquo;s object oriented programming features, we can encapsulate this behavior in a custom class, where the constructor can allocate the required memory and the destructor can release it when the instance goes out of scope.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RAIIFloat</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span><span style="color:#f92672">*</span> data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>     RAIIFloat(<span style="color:#66d9ef">float</span> value) {
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">float</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>RAIIFloat() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">delete</span> data;
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() <span style="color:#66d9ef">const</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>data <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    RAIIFloat x(<span style="color:#ae81ff">3.14</span>);
</span></span><span style="display:flex;"><span>    x.print();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>No dangling pointers, no <code>new</code>, no <code>delete</code>! And yet, consider the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> main() {
</span></span><span style="display:flex;"><span>    RAIIFloat <span style="color:#a6e22e">x</span>(<span style="color:#ae81ff">3.14</span>);
</span></span><span style="display:flex;"><span>    x.print();
</span></span><span style="display:flex;"><span>    RAIIFloat y <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>    y.print();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The program compiles fine, yet the error occurs at runtime when both <code>x</code> and <code>y</code> are destroyed. When <code>y</code> is assigned the value of <code>x</code> it effectively points <code>y</code> to the same resource (memory) as <code>x</code>, i.e. creating a shallow copy. So when the resource associated with <code>x</code> gets freed at the end of <code>x</code>&rsquo;s <em>lifetime</em>, the destruction of <code>y</code> complains of attempting to free a resource that already has been freed.</p>
<p><code>RAIIFloat</code> thus lacks an essential trait of RAII, which is that when the resource associated with an object is released, <em>the object should also die</em>. To correct this discrepancy we can either create a deep-copy of the object, or move it entirely to the new object (<em>single ownership</em>).</p>
<h3 id="deep-copy-while-retaining-ownership">Deep-copy while retaining ownership<a hidden class="anchor" aria-hidden="true" href="#deep-copy-while-retaining-ownership">#</a></h3>
<p>We can modify the copy constructor to perform a deep-copy instead of a shallow copy (also modifying the copy assignment operator to make deep copies).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RAIIFloat</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    RAIIFloat(<span style="color:#66d9ef">const</span> RAIIFloat<span style="color:#f92672">&amp;</span> other) {
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">float</span>(<span style="color:#f92672">*</span>(other.data));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    RAIIFloat<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> RAIIFloat <span style="color:#f92672">&amp;</span>other) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (data) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (data <span style="color:#f92672">!=</span> other.data) {
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>(other.data)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">float</span>(<span style="color:#f92672">*</span>(other.data));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The new copy constructor (and copy assignment constructor) makes acquisition and release of resources predictable and bound to the lifetime of the object.</p>
<h3 id="ownership-transfer-aka-move-semantics">Ownership transfer, a.k.a. move semantics<a hidden class="anchor" aria-hidden="true" href="#ownership-transfer-aka-move-semantics">#</a></h3>
<p>Alternatively, we can use <em>move semantics</em> in C++ to transfer ownership of a resource to the new object once it is reassigned. This transfer of ownership promotes reuse of existing resources and preserves adherence to RAII principles. Note that for simplicity, in this example we disable the copy constructor instead.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RAIIFloat</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>    RAIIFloat(RAIIFloat<span style="color:#f92672">&amp;&amp;</span> other) {
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> other.data;
</span></span><span style="display:flex;"><span>        other.data <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    RAIIFloat<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(RAIIFloat<span style="color:#f92672">&amp;&amp;</span> other) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (data <span style="color:#f92672">!=</span> other.data) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">delete</span> data;
</span></span><span style="display:flex;"><span>            data <span style="color:#f92672">=</span> other.data;
</span></span><span style="display:flex;"><span>            other.data <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    RAIIFloat(<span style="color:#66d9ef">const</span> RAIIFloat<span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>    RAIIFloat<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> RAIIFloat <span style="color:#f92672">&amp;</span>) <span style="color:#f92672">=</span> <span style="color:#66d9ef">delete</span>;
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>As a result, ownership is now moved to the new object on assignment.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> main() {
</span></span><span style="display:flex;"><span>    RAIIFloat <span style="color:#a6e22e">x</span>(<span style="color:#ae81ff">3.14</span>);
</span></span><span style="display:flex;"><span>    x.print();
</span></span><span style="display:flex;"><span>    RAIIFloat y <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(x);
</span></span><span style="display:flex;"><span>    y.print();
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// x.print();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Calling <code>x.print()</code> segfaults as <code>x</code> no longer owns the memory it was originally assigned.</p>
<h3 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h3>
<p>RAII is a programming pattern that ensures efficient and predictable allocation and cleanup of resources (file handles, heap memory, etc.) by tying the initiation and termination of their usage to the lifetime of the entity that invokes them. Using constructors and destructors provided in a programming language that facilitates an object oriented programming paradigm makes the implementation of RAII clean and programmer-friendly.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Stroustrup, B. (2001). Exception safety: concepts and techniques. In Advances in exception handling techniques (pp. 60-76). Berlin, Heidelberg: Springer Berlin Heidelberg. <a href="https://www.academia.edu/download/30747472/Alexander_Romanovsky_Advances_in_Exception_Hand.pdf#page=72">PDF</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Resource Acquisition Is Initialization on x"
            href="https://x.com/intent/tweet/?text=Resource%20Acquisition%20Is%20Initialization&amp;url=https%3a%2f%2fwww.debdebnath.com%2fposts%2fraii%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Resource Acquisition Is Initialization on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.debdebnath.com%2fposts%2fraii%2f&amp;title=Resource%20Acquisition%20Is%20Initialization&amp;summary=Resource%20Acquisition%20Is%20Initialization&amp;source=https%3a%2f%2fwww.debdebnath.com%2fposts%2fraii%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Resource Acquisition Is Initialization on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fwww.debdebnath.com%2fposts%2fraii%2f&title=Resource%20Acquisition%20Is%20Initialization">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://www.debdebnath.com/"></a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a><script>
document.addEventListener('DOMContentLoaded', function() {
  var accordions = document.getElementsByClassName("accordion-toggle");
  for (var i = 0; i < accordions.length; i++) {
    accordions[i].addEventListener("click", function() {
      this.classList.toggle("active");
      var content = this.nextElementSibling;
      if (content.style.maxHeight) {
        content.style.maxHeight = null;
      } else {
        content.style.maxHeight = content.scrollHeight + "px";
      }
    });
  }
});
</script>


<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
